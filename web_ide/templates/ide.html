{% extends 'base.html' %}
{% block content %}
<div class="row g-3">
  <div class="col-12 col-lg-3">
    <div class="card h-100">
      <div class="card-header d-flex align-items-center justify-content-between">
        <strong>Ø§Ù„Ù…Ù„ÙØ§Øª</strong>
        <div class="btn-group btn-group-sm" role="group">
          <a class="btn btn-primary" id="btn-new">+ Ø¬Ø¯ÙŠØ¯</a>
          <a class="btn btn-secondary" id="btn-refresh">ØªØ­Ø¯ÙŠØ«</a>
        </div>
      </div>
      <div class="px-3 py-2">
        <div class="btn-group btn-group-sm" role="group">
          <a class="btn btn-outline-light" id="btn-save-as">Ø­ÙØ¸ ÙƒÙ€</a>
          <a class="btn btn-outline-warning" id="btn-rename">Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ©</a>
          <a class="btn btn-outline-danger" id="btn-delete">Ø­Ø°Ù</a>
        </div>
      </div>
        <div id="file-list" class="list-group list-group-flush" style="max-height: 60vh; overflow:auto"></div>
      </div>
    </div>
  </div>
  <div class="col-12 col-lg-9">
    <div class="card">
      <div class="card-header d-flex align-items-center justify-content-between">
        <div>
          <span class="badge text-bg-dark" id="current-file">ØºÙŠØ± Ù…Ø­ÙÙˆØ¸</span>
        </div>
        <div class="d-flex gap-2 align-items-center">
          <a class="btn btn-sm btn-primary" id="btn-run">ØªØ´ØºÙŠÙ„</a>
          <a class="btn btn-sm btn-secondary" id="btn-run-selection">ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ø¯ÙŠØ¯</a>
          <a class="btn btn-sm btn-success" id="btn-save">Ø­ÙØ¸</a>
        </div>
      </div>
      <div class="px-3 py-2 d-flex flex-wrap align-items-center gap-2">
        <label class="form-label m-0 me-1">Ø£Ù…Ø«Ù„Ø©</label>
        <select id="sel-examples" class="form-select form-select-sm" style="width:auto; min-width: 220px"></select>
        <a class="btn btn-sm btn-outline-info" id="btn-load-example">ØªØ­Ù…ÙŠÙ„</a>
<input id="inp-example-filter" class="form-control form-control-sm" style="width: 160px" placeholder="Ø¨Ø­Ø«..." />
        <label class="form-label m-0 me-1">Ù…Ø¬Ø§Ù„ Ø§Ù„Ø£Ù…Ø«Ù„Ø©</label>
        <select id="sel-examples-domain" class="form-select form-select-sm" style="width:auto">
          <option value="all" selected>Ø§Ù„ÙƒÙ„</option>
          <option value="ai.ml">ai.ml</option>
          <option value="ai.nlp">ai.nlp</option>
          <option value="ai.data">ai.data</option>
          <option value="logic">logic</option>
          <option value="mixed">mixed</option>
          <option value="unknown">unknown</option>
        </select>
        <label class="form-label m-0 me-1">Ù„ØºØ© Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„</label>
        <select id="sel-ac-lang" class="form-select form-select-sm" style="width:auto">
          <option value="all" selected>Ø§Ù„ÙƒÙ„</option>
          <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
          <option value="en">English</option>
        </select>
        <label class="form-label m-0 me-1">Ù…Ø¬Ø§Ù„ Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„</label>
        <select id="sel-ac-domain" class="form-select form-select-sm" style="width:auto">
          <option value="all" selected>Ø§Ù„ÙƒÙ„</option>
          <option value="ai.ml">ai.ml</option>
          <option value="ai.nlp">ai.nlp</option>
          <option value="ai.data">ai.data</option>
          <option value="logic">logic</option>
        </select>
        <div class="vr mx-2"></div>
        <label class="form-label m-0 me-1">Ø§Ù„Ø³Ù…Ø©</label>
        <select id="sel-theme" class="form-select form-select-sm" style="width:auto">
          <option value="ace/theme/monokai" selected>Monokai</option>
          <option value="ace/theme/chrome">Chrome</option>
          <option value="ace/theme/dracula">Dracula</option>
        </select>
        <label class="form-label m-0 ms-2 me-1">Ø­Ø¬Ù… Ø§Ù„Ø®Ø·</label>
        <select id="sel-fontsize" class="form-select form-select-sm" style="width:auto">
          <option>12</option>
          <option selected>14</option>
          <option>16</option>
          <option>18</option>
        </select>
      <div id="example-info" class="px-3 py-1 text-muted small"></div>
      <div id="ac-info" class="px-3 py-1 text-muted small"></div>

      </div>
      <div id="editor" style="height: 55vh; width: 100%"></div>
      <div class="card-body">
        <h6 class="mb-2">Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª</h6>
        <pre id="output" class="p-3 rounded" style="background:#0b1220; border:1px solid #1f2a44; min-height: 18vh"></pre>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js" integrity="sha512-ycHu2LvbZqBz7lR71QwFIfuA0S1YxC4+NpiJziG52iMm7W/gQ6I+ttcSzopwGtSDAm0F1RG8WzUuZ6s0OqYoYg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.min.js" integrity="sha512-uXK1r6n6mGm0mQ0qJx/fekxR6oT9vHBt4D9p6VQKQ9YJXw1S6Vboy3V3uFqg+Kc9pFfz9wV2mL4ZtbnJ0H1pLw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
  // Minimal Bayan mode (keywords + comments)
  ace.define('ace/mode/bayan', function(require, exports, module) {
    var oop = require("ace/lib/oop");
    var TextMode = require("ace/mode/text").Mode;
    var TextHighlightRules = require("ace/mode/text_highlight_rules").TextHighlightRules;

    var BayanHighlightRules = function() {
      var keywords = (
        'and|as|assert|async|await|break|class|continue|def|del|elif|else|except|'
        + 'False|finally|for|from|global|if|import|include|in|is|lambda|None|nonlocal|'
        + 'not|or|pass|raise|return|True|try|while|with|yield|hybrid|fact|rule|query|assertz|retract|entity|apply|'
        + 'Ø¥Ø°Ø§|ÙˆØ¥Ù„Ø§|Ù„ÙƒÙ„|Ø¨ÙŠÙ†Ù…Ø§|Ø­Ù‚ÙŠÙ‚Ø©|Ù‚Ø§Ø¹Ø¯Ø©|Ø§Ø³ØªØ¹Ù„Ø§Ù…|ÙƒÙŠØ§Ù†|Ø·Ø¨Ù‚|Ø¥Ø¯Ø±Ø§Ø¬|Ø§Ø³ØªÙŠØ±Ø§Ø¯'
      );
      this.$rules = { start: [
        { token: 'comment.line.number-sign.bayan', regex: '#.*$' },
        { token: 'string.quoted.single.bayan', regex: "'(?:[^'\\\\]|\\\\.)*'" },
        { token: 'string.quoted.double.bayan', regex: '"(?:[^"\\\\]|\\\\.)*"' },
        { token: 'constant.numeric.bayan', regex: /\b[0-9]+(?:\.[0-9]+)?\b/ },
        { token: 'keyword.control.bayan', regex: new RegExp('\\b(' + keywords + ')\\b') }
      ]};
    };
    oop.inherits(BayanHighlightRules, TextHighlightRules);

    var Mode = function() { this.HighlightRules = BayanHighlightRules; };
    oop.inherits(Mode, TextMode);
    (function() { this.$id = 'ace/mode/bayan'; }).call(Mode.prototype);
    exports.Mode = Mode;
  });

  var editor = ace.edit('editor');
  editor.session.setMode('ace/mode/bayan');
  editor.setTheme('ace/theme/monokai');
  editor.setOptions({
    enableBasicAutocompletion: true,
    enableLiveAutocompletion: true,
    enableSnippets: true,
    fontSize: '14px',
    tabSize: 2,
    useSoftTabs: true,
    wrap: true,
    rtl: true
  });

  // Autocomplete: AI stdlib (English + Arabic) â€” curated popular entries
  const langTools = ace.require('ace/ext/language_tools');
  const aiCompletions = [
    // ML (supervised/unsupervised)
    {caption:'softmax_train', value:'softmax_train', meta:'ai.ml', score:90, docText:'Train softmax (multi-class logistic) classifier.'},
    {caption:'softmax_predict', value:'softmax_predict', meta:'ai.ml', score:90, docText:'Predict class labels using softmax model.'},
    {caption:'logistic_regression_train', value:'logistic_regression_train', meta:'ai.ml', docText:'Train binary logistic regression; returns [w,b].'},
    {caption:'logistic_regression_predict', value:'logistic_regression_predict', meta:'ai.ml', docText:'Predict 0/1 labels with threshold (default 0.5).'},
    {caption:'logistic_regression_predict_proba', value:'logistic_regression_predict_proba', meta:'ai.ml', docText:'Return probabilities for logistic regression.'},
    {caption:'k_nearest_neighbors_predict', value:'k_nearest_neighbors_predict', meta:'ai.ml', docText:'KNN classification for batch of samples.'},
    {caption:'k_means', value:'k_means', meta:'ai.ml', docText:'K-means clustering (deterministic init).'},
    {caption:'k_means_pp', value:'k_means_pp', meta:'ai.ml', docText:'K-means with k-means++ init (deterministic).'},
    {caption:'random_forest_train', value:'random_forest_train', meta:'ai.ml', docText:'Train simple random forest (educational).'},
    {caption:'random_forest_predict', value:'random_forest_predict', meta:'ai.ml', docText:'Predict with random forest model.'},
    {caption:'decision_tree_train', value:'decision_tree_train', meta:'ai.ml', docText:'Train decision tree classifier.'},
    {caption:'decision_tree_predict', value:'decision_tree_predict', meta:'ai.ml', docText:'Predict using decision tree.'},
    {caption:'accuracy_score', value:'accuracy_score', meta:'ai.ml', docText:'Classification accuracy.'},
    {caption:'precision_score', value:'precision_score', meta:'ai.ml', docText:'Precision for positive class.'},
    {caption:'recall_score', value:'recall_score', meta:'ai.ml', docText:'Recall for positive class.'},
    {caption:'f1_score', value:'f1_score', meta:'ai.ml', docText:'F1 = 2PR/(P+R).'},
    {caption:'confusion_matrix', value:'confusion_matrix', meta:'ai.ml', docText:'Binary confusion matrix [[tn,fp],[fn,tp]].'},
    {caption:'classification_report', value:'classification_report', meta:'ai.ml', docText:'Per-class precision/recall/F1 + averages.'},
    {caption:'pca_fit', value:'pca_fit', meta:'ai.ml', docText:'Compute PCA components.'},
    {caption:'pca_transform', value:'pca_transform', meta:'ai.ml', docText:'Project onto PCA components.'},
    {caption:'variance_threshold_fit', value:'variance_threshold_fit', meta:'ai.ml', docText:'Select features above variance threshold.'},
    {caption:'variance_threshold_transform', value:'variance_threshold_transform', meta:'ai.ml', docText:'Apply feature mask from fit.'},
    {caption:'train_test_split', value:'train_test_split', meta:'ai.ml', docText:'Deterministic split without shuffle.'},
    {caption:'train_test_split_stratified', value:'train_test_split_stratified', meta:'ai.ml', docText:'Label-stratified split; optional shuffle.'},
    {caption:'k_fold_indices', value:'k_fold_indices', meta:'ai.ml', docText:'K-fold indices generator.'},
    {caption:'stratified_k_fold_indices', value:'stratified_k_fold_indices', meta:'ai.ml', docText:'Stratified k-fold indices by labels.'},
    {caption:'grid_search_cv_softmax', value:'grid_search_cv_softmax', meta:'ai.ml', docText:'Grid search for softmax hyperparameters.'},
    {caption:'stacking_train', value:'stacking_train', meta:'ai.ml', docText:'Train simple stacking ensemble.'},
    {caption:'stacking_predict', value:'stacking_predict', meta:'ai.ml', docText:'Predict with stacking ensemble.'},
    {caption:'voting_classifier_predict', value:'voting_classifier_predict', meta:'ai.ml', docText:'Hard/soft voting across estimators.'},

    // NLP
    {caption:'preprocess_text', value:'preprocess_text', meta:'ai.nlp', docText:'Lowercase, remove punctuation, normalize spaces.'},
    {caption:'tokenize_text', value:'tokenize_text', meta:'ai.nlp', docText:'Naive whitespace tokenizer.'},
    {caption:'compute_tfidf', value:'compute_tfidf', meta:'ai.nlp', docText:'TF-IDF without logs (portable).'},
    {caption:'compute_tfidf_log', value:'compute_tfidf_log', meta:'ai.nlp', docText:'Log TF and smoothed IDF via binary-search ln.'},
    {caption:'compute_tfidf_log_norm', value:'compute_tfidf_log_norm', meta:'ai.nlp', docText:'TF-IDF (log) with L2 normalization.'},
    {caption:'compute_tfidf_options', value:'compute_tfidf_options', meta:'ai.nlp', docText:'TF-IDF with options: sublinear_tf, smooth_idf.'},
    {caption:'compute_tfidf_vocab_limit', value:'compute_tfidf_vocab_limit', meta:'ai.nlp', docText:'TF-IDF limited to top-k vocabulary.'},
    {caption:'soft_tfidf_build', value:'soft_tfidf_build', meta:'ai.nlp', docText:'Build Soft TF-IDF model with Jaroâ€“Winkler.'},
    {caption:'soft_tfidf_vector', value:'soft_tfidf_vector', meta:'ai.nlp', docText:'Compute soft TF-IDF vector for text.'},
    {caption:'soft_tfidf_cosine_similarity', value:'soft_tfidf_cosine_similarity', meta:'ai.nlp', docText:'Cosine similarity using soft TF-IDF.'},
    {caption:'bm25_build', value:'bm25_build', meta:'ai.nlp', docText:'Build BM25 data from docs.'},
    {caption:'bm25_score', value:'bm25_score', meta:'ai.nlp', docText:'BM25 scores for a query over docs.'},
    {caption:'bm25_top_k', value:'bm25_top_k', meta:'ai.nlp', docText:'Top-k docs by BM25 score.'},
    {caption:'bm25_score_with_term_weights', value:'bm25_score_with_term_weights', meta:'ai.nlp', docText:'BM25 with query-term weights.'},
    {caption:'tfidf_cosine_similarity', value:'tfidf_cosine_similarity', meta:'ai.nlp', docText:'Cosine similarity between two texts via TF-IDF.'},
    {caption:'cosine_similarity', value:'cosine_similarity', meta:'ai.nlp', docText:'Cosine over token lists (bag-of-words).'},
    {caption:'cosine_similarity_dicts', value:'cosine_similarity_dicts', meta:'ai.nlp', docText:'Cosine for term->weight dictionaries.'},
    {caption:'jaro_winkler_similarity', value:'jaro_winkler_similarity', meta:'ai.nlp', docText:'Jaroâ€“Winkler string similarity.'},
    {caption:'jaro_similarity', value:'jaro_similarity', meta:'ai.nlp', docText:'Jaro string similarity.'},
    {caption:'levenshtein_distance', value:'levenshtein_distance', meta:'ai.nlp', docText:'Edit distance (Levenshtein).'},
    {caption:'damerau_levenshtein_distance', value:'damerau_levenshtein_distance', meta:'ai.nlp', docText:'Edit distance with transposition.'},
    {caption:'lcs_length', value:'lcs_length', meta:'ai.nlp', docText:'Longest Common Subsequence length.'},
    {caption:'jaccard_char_ngrams', value:'jaccard_char_ngrams', meta:'ai.nlp', docText:'Jaccard over character n-grams.'},
    {caption:'dice_char_ngrams', value:'dice_char_ngrams', meta:'ai.nlp', docText:'SÃ¸rensenâ€“Dice over character n-grams.'},
    {caption:'normalize_arabic', value:'normalize_arabic', meta:'ai.nlp', docText:'Normalize Arabic forms and diacritics.'},
    {caption:'arabic_light_stem_tokens', value:'arabic_light_stem_tokens', meta:'ai.nlp', docText:'Light stemming for Arabic tokens.'},
    {caption:'remove_stopwords', value:'remove_stopwords', meta:'ai.nlp', docText:'Remove stopwords (auto language).'},
    {caption:'remove_stopwords_extended', value:'remove_stopwords_extended', meta:'ai.nlp', docText:'Remove stopwords with extended lists.'},

    // DATA
    {caption:'parse_csv_rows', value:'parse_csv_rows', meta:'ai.data', docText:'Parse CSV into list of fields per row.'},
    {caption:'read_csv_string', value:'read_csv_string', meta:'ai.data', docText:'Parse CSV from a single string.'},
    {caption:'write_csv_string', value:'write_csv_string', meta:'ai.data', docText:'Serialize rows to CSV string.'},
    {caption:'read_json_string', value:'read_json_string', meta:'ai.data', docText:'Parse simple JSON (educational).'},
    {caption:'write_json_array_string', value:'write_json_array_string', meta:'ai.data', docText:'Serialize string list to JSON array.'},
    {caption:'write_json_object_string', value:'write_json_object_string', meta:'ai.data', docText:'Serialize dict(str->str) to JSON object.'},
    {caption:'mean', value:'mean', meta:'ai.data', docText:'Arithmetic mean.'},
    {caption:'variance', value:'variance', meta:'ai.data', docText:'Population variance.'},
    {caption:'stddev', value:'stddev', meta:'ai.data', docText:'Standard deviation.'},
    {caption:'median', value:'median', meta:'ai.data', docText:'Median (selection sort based).'},
    {caption:'percentile', value:'percentile', meta:'ai.data', docText:'Linear interpolation percentile.'},
    {caption:'quantiles', value:'quantiles', meta:'ai.data', docText:'Multiple percentiles from [0,1] list.'},
    {caption:'iqr', value:'iqr', meta:'ai.data', docText:'Interquartile range (Tukey).'},
    {caption:'pearson_r', value:'pearson_r', meta:'ai.data', docText:'Pearson correlation coefficient.'},
    {caption:'minmax_normalize', value:'minmax_normalize', meta:'ai.data', docText:'Scale to [0,1].'},
    {caption:'zscore_normalize', value:'zscore_normalize', meta:'ai.data', docText:'Standardize array using mean/std.'},
    {caption:'standard_scaler_fit', value:'standard_scaler_fit', meta:'ai.data', docText:'Compute mean/std.'},
    {caption:'standard_scaler_transform', value:'standard_scaler_transform', meta:'ai.data', docText:'Apply standard scaling.'},
    {caption:'robust_scaler_fit', value:'robust_scaler_fit', meta:'ai.data', docText:'Compute median/IQR.'},
    {caption:'robust_scaler_transform', value:'robust_scaler_transform', meta:'ai.data', docText:'Apply robust scaling.'},
    {caption:'minmax_scaler_fit', value:'minmax_scaler_fit', meta:'ai.data', docText:'Compute min/max.'},
    {caption:'minmax_scaler_transform', value:'minmax_scaler_transform', meta:'ai.data', docText:'Apply min-max scaling.'},
    {caption:'bin_equal_width', value:'bin_equal_width', meta:'ai.data', docText:'Equal-width discretization to bin indices.'},
    {caption:'one_hot_encode', value:'one_hot_encode', meta:'ai.data', docText:'One-hot encode integer indices.'},
    {caption:'label_encoder_fit', value:'label_encoder_fit', meta:'ai.data', docText:'Build label vocabulary.'},
    {caption:'label_encoder_transform', value:'label_encoder_transform', meta:'ai.data', docText:'Map labels to indices.'},
    {caption:'frequency_encoder_fit', value:'frequency_encoder_fit', meta:'ai.data', docText:'Compute label frequencies.'},
    {caption:'frequency_encoder_transform', value:'frequency_encoder_transform', meta:'ai.data', docText:'Map labels to frequency.'},
    {caption:'target_encoder_fit', value:'target_encoder_fit', meta:'ai.data', docText:'Mean encoding per category.'},
    {caption:'target_encoder_transform', value:'target_encoder_transform', meta:'ai.data', docText:'Map by learned means (fallback global).'},
    {caption:'random_permutation', value:'random_permutation', meta:'ai.data', docText:'Deterministic Fisherâ€“Yates perm.'},
    {caption:'set_seed', value:'set_seed', meta:'ai.data', docText:'Set global PRNG seed.'},
    {caption:'rand', value:'rand', meta:'ai.data', docText:'Uniform random in [0,1).'},
    {caption:'randint', value:'randint', meta:'ai.data', docText:'Random integer in [a,b].'},
    {caption:'shuffle_list', value:'shuffle_list', meta:'ai.data', docText:'Shuffle copy using PRNG.'},
    {caption:'sample_list', value:'sample_list', meta:'ai.data', docText:'Sample k unique elements.'},
    {caption:'train_test_split_shuffle', value:'train_test_split_shuffle', meta:'ai.data', docText:'Shuffle split using PRNG.'},
    {caption:'pipeline_fit_transform', value:'pipeline_fit_transform', meta:'ai.data', docText:'Fit sequential steps; returns [X_out, models].'},
    {caption:'pipeline_transform', value:'pipeline_transform', meta:'ai.data', docText:'Transform using fitted models.'},

    // Arabic wrappers (selected)
    {caption:'ØªØ¯Ø±ÙŠØ¨_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', value:'ØªØ¯Ø±ÙŠØ¨_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', meta:'ai.ar', docText:'Arabic alias: logistic_regression_train.'},
    {caption:'ØªÙˆÙ‚Ø¹_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', value:'ØªÙˆÙ‚Ø¹_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', meta:'ai.ar', docText:'Arabic alias: logistic_regression_predict.'},
    {caption:'Ø§Ù†Ø­Ø¯Ø§Ø±_Ø®Ø·ÙŠ', value:'Ø§Ù†Ø­Ø¯Ø§Ø±_Ø®Ø·ÙŠ', meta:'ai.ar', docText:'Arabic alias: linear_regression.'},
    {caption:'ØªØ¬Ù…ÙŠØ¹_ÙƒÙŠ_Ù…ÙŠÙ†Ø²', value:'ØªØ¬Ù…ÙŠØ¹_ÙƒÙŠ_Ù…ÙŠÙ†Ø²', meta:'ai.ar', docText:'Arabic alias: k_means.'},
    {caption:'Ù…ØµÙÙˆÙØ©_Ø§Ù„Ø§Ù„ØªØ¨Ø§Ø³', value:'Ù…ØµÙÙˆÙØ©_Ø§Ù„Ø§Ù„ØªØ¨Ø§Ø³', meta:'ai.ar', docText:'Arabic alias: confusion_matrix.'},
    {caption:'ØªØ´Ø§Ø¨Ù‡_Ø¬ÙŠØ¨ÙŠ', value:'ØªØ´Ø§Ø¨Ù‡_Ø¬ÙŠØ¨ÙŠ', meta:'ai.ar', docText:'Arabic alias: cosine_similarity (lists).'},
    {caption:'Ø­Ø³Ø§Ø¨_tfidf', value:'Ø­Ø³Ø§Ø¨_tfidf', meta:'ai.ar', docText:'Arabic alias: compute_tfidf.'},
    {caption:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº', value:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº', meta:'ai.ar', docText:'Arabic alias: compute_tfidf_log.'},
    {caption:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº_Ù…Ø·Ø¨Ø¹', value:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº_Ù…Ø·Ø¨Ø¹', meta:'ai.ar', docText:'Arabic alias: compute_tfidf_log_norm.'},
    {caption:'Ù…Ù„Ø§Ø¡Ù…Ø©_ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', value:'Ù…Ù„Ø§Ø¡Ù…Ø©_ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', meta:'ai.ar', docText:'Arabic alias: pipeline_fit_transform.'},
    {caption:'ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', value:'ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', meta:'ai.ar', docText:'Arabic alias: pipeline_transform.'},
    {caption:'Ù‚Ø±Ø§Ø¡Ø©_CSV_Ù†Øµ', value:'Ù‚Ø±Ø§Ø¡Ø©_CSV_Ù†Øµ', meta:'ai.ar', docText:'Arabic alias: read_csv_string.'},
    {caption:'ÙƒØªØ§Ø¨Ø©_CSV_Ù†Øµ', value:'ÙƒØªØ§Ø¨Ø©_CSV_Ù†Øµ', meta:'ai.ar', docText:'Arabic alias: write_csv_string.'},
    {caption:'ØªØ·Ø¨ÙŠØ¹_Ø£Ø¯Ù†Ù‰_Ø£Ù‚ØµÙ‰', value:'ØªØ·Ø¨ÙŠØ¹_Ø£Ø¯Ù†Ù‰_Ø£Ù‚ØµÙ‰', meta:'ai.ar', docText:'Arabic alias: minmax_normalize.'},
    {caption:'ØªØ·Ø¨ÙŠØ¹_Z', value:'ØªØ·Ø¨ÙŠØ¹_Z', meta:'ai.ar', docText:'Arabic alias: zscore_normalize.'},
    {caption:'ØªØ±ØªÙŠØ¨_Ø¹Ø´ÙˆØ§Ø¦ÙŠ', value:'ØªØ±ØªÙŠØ¨_Ø¹Ø´ÙˆØ§Ø¦ÙŠ', meta:'ai.ar', docText:'Arabic alias: random_permutation.'},

    // LOGIC (language/hybrid helpers)
    {caption:'fact', value:'fact ', meta:'logic', score:70, docText:'Define a logic fact (ends with a dot).'},
    {caption:'rule', value:'rule ', meta:'logic', score:70, docText:'Define a logic rule: head :- body.'},
    {caption:'query', value:'query ', meta:'logic', score:70, docText:'Run a logic query; results shown in output.'},
    {caption:'assertz', value:'assertz(', meta:'logic', score:65, docText:'Dynamically add a fact at runtime.'},
    {caption:'retract', value:'retract(', meta:'logic', score:65, docText:'Dynamically remove a fact at runtime.'},
    {caption:'entity', value:'entity ', meta:'logic', score:60, docText:'Define an entity (states/properties/actions).'},
    {caption:'apply', value:'apply ', meta:'logic', score:60, docText:'Apply an action to a target entity.'},

    // Arabic aliases (logic)
    {caption:'Ø­Ù‚ÙŠÙ‚Ø©', value:'Ø­Ù‚ÙŠÙ‚Ø© ', meta:'logic', score:70, docText:'ØªØ¹Ø±ÙŠÙ Ø­Ù‚ÙŠÙ‚Ø© Ù…Ù†Ø·Ù‚ÙŠØ© ØªÙ†ØªÙ‡ÙŠ Ø¨Ù†Ù‚Ø·Ø©.', ar:true},
    {caption:'Ù‚Ø§Ø¹Ø¯Ø©', value:'Ù‚Ø§Ø¹Ø¯Ø© ', meta:'logic', score:70, docText:'ØªØ¹Ø±ÙŠÙ Ù‚Ø§Ø¹Ø¯Ø©: Ø§Ù„Ø±Ø£Ø³ :- Ø§Ù„Ø¬Ø³Ù….', ar:true},
    {caption:'Ø§Ø³ØªØ¹Ù„Ø§Ù…', value:'Ø§Ø³ØªØ¹Ù„Ø§Ù… ', meta:'logic', score:70, docText:'ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù…Ù†Ø·Ù‚ÙŠ ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬.', ar:true},
    {caption:'ÙƒÙŠØ§Ù†', value:'ÙƒÙŠØ§Ù† ', meta:'logic', score:60, docText:'ØªØ¹Ø±ÙŠÙ ÙƒÙŠØ§Ù† Ø¨Ø®ØµØ§Ø¦Øµ/Ø­Ø§Ù„Ø§Øª/Ø£ÙØ¹Ø§Ù„.', ar:true},
    {caption:'Ø·Ø¨Ù‚', value:'Ø·Ø¨Ù‚ ', meta:'logic', score:60, docText:'ØªØ·Ø¨ÙŠÙ‚ ÙØ¹Ù„ Ø¹Ù„Ù‰ ÙƒÙŠØ§Ù† Ù…Ø³ØªÙ‡Ø¯Ù.', ar:true},

    {caption:'ØªÙ‚Ø³ÙŠÙ…_Ø¹Ø´ÙˆØ§Ø¦ÙŠ_ØªØ¯Ø±ÙŠØ¨_Ø§Ø®ØªØ¨Ø§Ø±', value:'ØªÙ‚Ø³ÙŠÙ…_Ø¹Ø´ÙˆØ§Ø¦ÙŠ_ØªØ¯Ø±ÙŠØ¨_Ø§Ø®ØªØ¨Ø§Ø±', meta:'ai.ar', docText:'Arabic alias: train_test_split_shuffle.'}
  ];
  const isArabicName = (s) => /[^\x00-\x7F]/.test(s || '');
  let completionLangMode = 'all';
  let completionDomainMode = 'all';
  const aiCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
      const compsRaw = aiCompletions.map(it => ({
        caption: it.caption,
        value: it.value,
        meta: it.meta,
        score: it.score || 80,
        docText: it.docText,
        ar: (typeof it.ar === 'boolean' ? it.ar : isArabicName(it.caption))
      }));
      let comps = compsRaw;
      if (completionLangMode === 'ar') comps = comps.filter(c => c.ar);
      else if (completionLangMode === 'en') comps = comps.filter(c => !c.ar);
      if (completionDomainMode !== 'all') comps = comps.filter(c => (c.meta || '') === completionDomainMode);
      callback(null, comps);
    }
  };
  langTools.addCompleter(aiCompleter);


  // Dynamic: load all AI functions (English + Arabic) from backend and merge
  try {
    fetch('/api/ide/ai_functions').then(r => r.json()).then(items => {
      const seen = new Set(aiCompletions.map(c => c.caption));
      items.forEach(fn => {
        if (!seen.has(fn.name)) {
          aiCompletions.push({
            caption: fn.name,
            value: fn.name,
            meta: fn.meta || 'ai',
            score: fn.ar ? 92 : 85,
            docText: fn.doc || '',
            ar: !!fn.ar
          });
          seen.add(fn.name);
        } else {
          const i = aiCompletions.findIndex(c => c.caption === fn.name);
          if (i >= 0) {
            if (fn.meta) aiCompletions[i].meta = fn.meta;
            if (!aiCompletions[i].docText && fn.doc) aiCompletions[i].docText = fn.doc;
            if (typeof aiCompletions[i].ar !== 'boolean') aiCompletions[i].ar = !!fn.ar;
          }
        }
      });
    }).catch(() => {});
  } catch (e) {}

  editor.setValue(`# Ù…Ø«Ø§Ù„ Ø³Ø±ÙŠØ¹\n\nprint("Hello Bayan!\n")\n\nclass A:{\n  def who():{ print("A") }\n}\n\nb = A()\nb.who()\n\n# Ù…Ù†Ø·Ù‚\nhybrid{\n  fact edge(a,b).\n  fact edge(b,c).\n  rule reachable(X,Y) :- edge(X,Y).\n  rule reachable(X,Y) :- edge(X,Z), reachable(Z,Y).\n  print("reachable(a, ?Y):")\n  query reachable(a, ?Y).\n}\n`, 1);

  const outputPre = document.getElementById('output');
  const currentFileBadge = document.getElementById('current-file');
  let currentFile = null;

  editor.session.getUndoManager().markClean();
  const updateDirty = () => {
    const clean = editor.session.getUndoManager().isClean();
    window.onbeforeunload = clean ? null : function(e){ e.preventDefault(); e.returnValue=''; };
  };
  updateDirty();

  // Static keyword completer
  const keywords = [
    'class','def','return','if','elif','else','while','for','break','continue','try','except','finally','raise','assert','with','yield','async','await','import','from','as','pass','True','False','None','hybrid','fact','rule','query','print','super'
  ];
  const staticCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
      const completions = keywords.map(k => ({
        caption: k, value: k, meta: 'kw', score: 50
      }));
      callback(null, completions);
    }
  };
  langTools.addCompleter(staticCompleter);

  async function refreshFiles() {
    const res = await fetch('/api/ide/files');
    const files = await res.json();
    const list = document.getElementById('file-list');
    list.innerHTML = '';
    files.forEach(f => {
      const a = document.createElement('a');
      a.href = '#';
      a.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
      a.textContent = f.name;
      a.onclick = async (e) => {
        e.preventDefault();

        const r = await fetch(`/api/ide/file?name=${encodeURIComponent(f.name)}`);
        if (r.ok) {
          const data = await r.json();
          editor.setValue(data.content, 1);
          currentFile = data.name;
          currentFileBadge.textContent = currentFile;
              editor.session.getUndoManager().markClean();
              updateDirty();

        }
      };
      list.appendChild(a);
    });
  }

  async function saveFile(asNew=false) {
    let name = currentFile;
    if (!name || asNew) {
      name = prompt('Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù (ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ .bayan):', name || 'program.bayan');
      if (!name) return;
    }
    const res = await fetch('/api/ide/file', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, content: editor.getValue() })
    });
    if (res.ok) {
      currentFile = name; currentFileBadge.textContent = name; refreshFiles();
      editor.session.getUndoManager().markClean();
      updateDirty();
    } else {
      alert('ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸');
    }
  }

  async function run(code) {
    outputPre.textContent = '...';
    const res = await fetch('/api/ide/run', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code })
    });
    const data = await res.json();
    if (data.success) {
      editor.session.clearAnnotations();
      let out = '';
      if (data.stdout) out += data.stdout;
      if (data.result !== null && data.result !== undefined) {
        out += `\n[Result(JSON)]: ${JSON.stringify(data.result)}`;
      } else if (data.result_repr) {
        out += `\n[Result]: ${data.result_repr}`;
      }
      outputPre.textContent = out;
    } else {
      annotateError(data.error, data.traceback);
      outputPre.textContent = `Error: ${data.error_type}: ${data.error}\n${data.traceback || ''}`;
    }
  }

  function annotateError(errorText, traceback) {
    try {
      const text = (traceback || '') + '\n' + (errorText || '');
      const m = text.match(/line\s+(\d+)/i);
      if (m) {
        const row = Math.max(0, parseInt(m[1], 10) - 1);
        editor.session.setAnnotations([{ row, column: 0, text: errorText || 'Error', type: 'error' }]);
        editor.scrollToLine(row, true, true, function(){});
        editor.gotoLine(row + 1, 0, true);
      }
    } catch (e) {}
  }

  let examplesMaster = [];
  async function refreshExamples() {
    try {
      const res = await fetch('/api/ide/examples');
      examplesMaster = await res.json();
      applyExamplesFilter();
    } catch (e) {}
  }
  function domainEmoji(d){
    switch(d){
      case 'ai.ml': return 'ğŸŸ©';
      case 'ai.nlp': return 'ğŸŸ¦';
      case 'ai.data': return 'ğŸŸ¨';
      case 'logic': return 'ğŸŸª';
      case 'mixed': return 'ğŸŸ§';
      default: return 'âšª';
    }
  }


  function renderExamples(list) {
    const sel = document.getElementById('sel-examples');
    sel.innerHTML = '';
    list.forEach(it => {
      const opt = document.createElement('option');
      opt.value = it.name;
      const domLabel = (it.domain || 'unknown');
      const badge = domainEmoji(domLabel);
      opt.textContent = `${badge} [${domLabel}] ${it.name}`;
      if (it.desc) opt.title = it.desc;
      else opt.title = it.name;
      sel.appendChild(opt);
    });
  }

  function applyExamplesFilter() {
    const q = (document.getElementById('inp-example-filter').value || '').toLowerCase();
    const dom = (document.getElementById('sel-examples-domain').value || 'all');
    let list = examplesMaster || [];
    if (dom !== 'all') list = list.filter(it => (it.domain || 'unknown') === dom);
    if (q) list = list.filter(it => (it.name || '').toLowerCase().includes(q));
    renderExamples(list);
    updateExampleInfo();
  }

  function updateExampleInfo() {
    try {
      const el = document.getElementById('example-info');
      const sel = document.getElementById('sel-examples');
      if (!el || !sel) return;
      const name = sel.value;
      const it = (examplesMaster || []).find(x => x.name === name);
      if (it) {
        const domLabel = (it.domain || 'unknown');
        const badge = domainEmoji(domLabel);
        el.textContent = `Ù…Ø«Ø§Ù„: ${badge} [${domLabel}] ${it.name} â€” ${it.desc || ''}`;
      } else el.textContent = '';
    } catch (e) {}
  }

  function setAcInfo(t) {
    const el = document.getElementById('ac-info');
    if (el) el.textContent = t ? ('ÙˆØµÙ Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„: ' + t) : '';
  }

  function setupAutocompleteInfo() {
    try {
      editor.commands.on('afterExec', function(e) {
        if (e && e.command && e.command.name === 'startAutocomplete') {
          const compl = editor.completer;
          const popup = compl && compl.popup;
          if (popup && !popup._descHook) {
            popup._descHook = true;
            popup.on('changeSelection', function() {
              try {
                const row = popup.getRow();
                const data = popup.data;
                const it = data && data[row];
                const t = (it && (it.docText || it.caption || '')) || '';
                setAcInfo(t);
              } catch (_) {}
            });
          }
        }
      });
    } catch (e) {}
  }

  function setupShortcuts() {
    editor.commands.addCommand({
      name: 'save', bindKey: { win: 'Ctrl-S', mac: 'Command-S' },
      exec: () => saveFile(false)
    });
    editor.commands.addCommand({
      name: 'run', bindKey: { win: 'Ctrl-Enter', mac: 'Command-Enter' },
      exec: () => run(editor.getValue())
    });
    editor.commands.addCommand({
      name: 'runSelection', bindKey: { win: 'Shift-Ctrl-Enter', mac: 'Shift-Command-Enter' },
      exec: () => {
        const sel = editor.session.getTextRange(editor.getSelectionRange());

        run(sel || editor.getValue());
      }
    });
    editor.session.on('change', updateDirty);
  }


  // Buttons
  document.getElementById('btn-refresh').onclick = refreshFiles;
  document.getElementById('btn-new').onclick = () => { currentFile = null; currentFileBadge.textContent = 'ØºÙŠØ± Ù…Ø­ÙÙˆØ¸'; editor.setValue('',1); updateDirty(); };
  document.getElementById('btn-save').onclick = () => saveFile(false);
  document.getElementById('btn-save-as').onclick = () => saveFile(true);
  document.getElementById('btn-rename').onclick = async () => {
    if (!currentFile) return alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ù…ÙØªÙˆØ­');
    const name = prompt('Ø§Ø³Ù… Ø¬Ø¯ÙŠØ¯:', currentFile);
    if (!name || name === currentFile) return;
    const res = await fetch('/api/ide/rename', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ old_name: currentFile, new_name: name })
    });
    if (res.ok) { currentFile = name; currentFileBadge.textContent = name; refreshFiles(); }
  };
  document.getElementById('btn-delete').onclick = async () => {
    if (!currentFile) return alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ù…ÙØªÙˆØ­');
    if (!confirm('Ø­Ø°Ù Ø§Ù„Ù…Ù„ÙØŸ')) return;
    const res = await fetch(`/api/ide/file?name=${encodeURIComponent(currentFile)}`, { method: 'DELETE' });
    if (res.ok) { currentFile = null; currentFileBadge.textContent = 'ØºÙŠØ± Ù…Ø­ÙÙˆØ¸'; editor.setValue('',1); refreshFiles(); }
  };
  document.getElementById('btn-run').onclick = () => run(editor.getValue());
  document.getElementById('btn-run-selection').onclick = () => {
    const sel = editor.session.getTextRange(editor.getSelectionRange());
    run(sel || editor.getValue());
  };

  // Toolbar handlers
  document.getElementById('btn-load-example').onclick = async () => {
    const sel = document.getElementById('sel-examples');
    const name = sel.value;
    if (!name) return;
    const r = await fetch(`/api/ide/example?name=${encodeURIComponent(name)}`);
    if (r.ok) {

      const data = await r.json();
      editor.setValue(data.code, 1);
      currentFile = null;
      currentFileBadge.textContent = 'ØºÙŠØ± Ù…Ø­ÙÙˆØ¸';
      editor.session.getUndoManager().markClean();
      updateDirty();
    }
  };
  document.getElementById('sel-theme').onchange = (e) => editor.setTheme(e.target.value);
  document.getElementById('sel-fontsize').onchange = (e) => editor.setFontSize(parseInt(e.target.value, 10) || 14);

  document.getElementById('sel-ac-domain').onchange = (e) => { completionDomainMode = e.target.value; };
  document.getElementById('sel-ac-lang').onchange = (e) => { completionLangMode = e.target.value; };
  document.getElementById('sel-examples-domain').onchange = applyExamplesFilter;
  document.getElementById('inp-example-filter').oninput = applyExamplesFilter;
  document.getElementById('sel-examples').onchange = updateExampleInfo;
  setupAutocompleteInfo();


  // init
  refreshFiles();
  refreshExamples();
  setupShortcuts();

</script>
{% endblock %}

